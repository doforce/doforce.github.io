<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Data Binding （中文文档） | Breathing Land</title><meta name="keywords" content="translation,android"><meta name="author" content="Edgar"><meta name="copyright" content="Edgar"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Data Binding 类库这篇文档将教你如何运用 Data Binding 类库来编写声明试布局，并且尽量减少粘合代码对你的应用逻辑和布局上的绑定。Data Binding 是一种灵活和广泛兼容的类库，它是一个支持库，因此你可以在任何 Android 2.1(API level 7+) 以上的设备 使用。为了使用 Data Binding，Android Gradle 插件版本必须为  1.5">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Binding （中文文档）">
<meta property="og:url" content="https://doforce.github.io/2018/translation/android-data-binding-translation/index.html">
<meta property="og:site_name" content="Breathing Land">
<meta property="og:description" content="Data Binding 类库这篇文档将教你如何运用 Data Binding 类库来编写声明试布局，并且尽量减少粘合代码对你的应用逻辑和布局上的绑定。Data Binding 是一种灵活和广泛兼容的类库，它是一个支持库，因此你可以在任何 Android 2.1(API level 7+) 以上的设备 使用。为了使用 Data Binding，Android Gradle 插件版本必须为  1.5">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2018-01-16T03:43:00.000Z">
<meta property="article:modified_time" content="2022-07-08T07:03:53.522Z">
<meta property="article:author" content="Edgar">
<meta property="article:tag" content="translation">
<meta property="article:tag" content="android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://doforce.github.io/2018/translation/android-data-binding-translation/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Data Binding （中文文档）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-08 15:03:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Breathing Land</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Data Binding （中文文档）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-01-16T03:43:00.000Z" title="发表于 2018-01-16 11:43:00">2018-01-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-08T07:03:53.522Z" title="更新于 2022-07-08 15:03:53">2022-07-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Data Binding （中文文档）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Data-Binding-类库"><a href="#Data-Binding-类库" class="headerlink" title="Data Binding 类库"></a>Data Binding 类库</h1><p>这篇文档将教你如何运用 Data Binding 类库来编写声明试布局，并且尽量减少粘合代码对你的应用逻辑和布局上的绑定。<br>Data Binding 是一种灵活和广泛兼容的类库，它是一个支持库，因此你可以在任何 Android 2.1(API level 7+) 以上的设备 使用。<br>为了使用 Data Binding，Android Gradle 插件版本必须为  1.5.0-alpha1 或以上，查看 <a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/releases/gradle-plugin.html#updating-plugin">如何升级你的 Gradle 插件</a>。</p>
<h2 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h2><p>为了获取 Data Binding，去 Android SDK manager 下载 它的支持库。<br>在你的应用 module 的 <code>build.gradle</code>  添加 dataBinding 来让你的应用支持  Data Binding。<br>用以下代码片段来配置 Data Binding:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ....</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若你有一个应用 module 用了一个依赖了 Data Binding 的类库，也一样要在该 module 中配置开启 Data Binding。<br>另外，如果想使用 Data Binding，你们你的 Android Studio 版本必须等于或大于 1.3。</p>
<hr>
<h2 id="Data-Binding-布局文件"><a href="#Data-Binding-布局文件" class="headerlink" title="Data Binding 布局文件"></a>Data Binding 布局文件</h2><h3 id="编写你的第一个-Data-Binding-表达式"><a href="#编写你的第一个-Data-Binding-表达式" class="headerlink" title="编写你的第一个 Data Binding 表达式"></a>编写你的第一个 Data Binding 表达式</h3><p>Data Binding 的布局文件有一点不一样，它以 <code>layout</code> 标签作为根标签，并且有一个<code> data</code> 元素和 一个 <code>view</code> 元素作为子标签，这个 <code>view </code> 元素就是你没有使用  Data Binding 时该有的布局文件。以下是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">   &lt;data&gt;</span><br><span class="line">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">   &lt;/data&gt;</span><br><span class="line">   &lt;LinearLayout</span><br><span class="line">       android:orientation=&quot;vertical&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">       &lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:text=&quot;@&#123;user.firstName&#125;&quot;/&gt;</span><br><span class="line">       &lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:text=&quot;@&#123;user.lastName&#125;&quot;/&gt;</span><br><span class="line">   &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>
<p><code>data</code> 标签下的 <code>variable</code> 是你在这个 Data Binding 布局文件中有可能使用到的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>布局中使用 <code>@&#123;&#125;</code> 语法来包裹 <code>variable</code> 中的对象属性，在下面例子中，<code>TextView</code> 的 <code>text</code> 属性的值用 <code>user</code> 的 <code>firstName</code> 属性来替代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">          android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">          android:text=&quot;@&#123;user.firstName&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>现在让我们假设你有一个普通的 Java 对象（POJO）<code>User</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">   public final String firstName;</span><br><span class="line">   public final String lastName;</span><br><span class="line">   public User(String firstName, String lastName) &#123;</span><br><span class="line">       this.firstName = firstName;</span><br><span class="line">       this.lastName = lastName;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个对象属性（final 修饰）是不可变的，如果你的数据对象只提供只读权限并且之后不会再去修改的话，这种做法很普遍。我们也可以用 JavaBeans  对象来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">   private final String firstName;</span><br><span class="line">   private final String lastName;</span><br><span class="line">   public User(String firstName, String lastName) &#123;</span><br><span class="line">       this.firstName = firstName;</span><br><span class="line">       this.lastName = lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getFirstName() &#123;</span><br><span class="line">       return this.firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getLastName() &#123;</span><br><span class="line">       return this.lastName;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从数据绑定的角度来看，这两个类是等价的。<code>TextView</code> 的  <code>android:text</code> 属性值会通过表达式 <code>@&#123;user.firstName&#125;</code>   来获取第一个类中的 <code>fistName</code> 字段值，活着获取第二个类中的 <code>getFirstName()</code> 方法返回的值。另外，如果 <code>firstName()</code> 方法存在的话也是可以获取到值的。</p>
<h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><p>默认情况下，将根据布局文件的名称生成一个绑定类，将其转换为 Pascal 格式并将 <code>Binding</code> 作为其后缀。上面的布局文件是名称<br> <code>main_activity.xml</code> ，因此生成的绑定类是 <code>MainActivityBinding</code>。这个类将布局属性（例如用户变量）绑定到布局的视图中，并知道如何通过表达式来赋值。创建绑定类的最简单方式是在视图 inflate 的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">   super.onCreate(savedInstanceState);</span><br><span class="line">   MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity);</span><br><span class="line">   User user = new User(&quot;Test&quot;, &quot;User&quot;);</span><br><span class="line">   binding.setUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成了！运行这个应用，你会在界面中看到测试的 <code>User</code>。另外，你可以通过一些方<br>式获取绑定类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater());</span><br></pre></td></tr></table></figure>
<p>如果你在 <code>ListView</code> 或者 <code>RecyclerView</code> 中使用数据绑定电话，你可以通过一些方式获取绑定类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false);</span><br><span class="line">//or</span><br><span class="line">ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false);</span><br></pre></td></tr></table></figure>

<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>数据绑定允许你编写表达式来处理从视图中分派的事件（例如 <code>onClick</code>）。除少数例外，事件属性名称由侦听器中的方法名称来确定。例如，<code>View.OnLongClickListener</code> 有一个 <code>onLongClick()</code>方法，所以这个事件的属性是 <code>android：onLongClick</code>。有以下两种方式来处理一个事件。</p>
<ul>
<li><strong>方法引用</strong>：在表达式中，可以引用符合侦听器方法签名的方法。 当表达式被评估为方法引用时，数据绑定将方法引用和所有者对象包装在侦听器中，并将该侦听器设置在目标视图上。 如果表达式被评估为 null，则数据绑定不会创建侦听器，而是设置一个空的侦听器。</li>
<li><strong>监听器绑定</strong>：当事件发生时，lambda 表达式将被评估。 数据绑定总是会在视图上创建一个监听器。 当事件被发送时，监听器将评估 lambda 表达式。</li>
</ul>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>事件可以直接绑定到处理的方法中，类似于 <code>android:onClick</code> 可以作为 Activity 的一个方法一样。与 <code>View＃onClick</code> 属性相比，一个主要的优点是表达式在编译时被处理，因此如果方法不存在或者它的签名不正确，就会收到编译时错误。</p>
<p>方法引用和监听器绑定的主要区别在于实际的监听器实现是在绑定数据时创建的，而不是在事件触发时创建的。</p>
<p>要将事件分配给其处理程序，请使用常规绑定表达式，其值是要调用的方法名称。 例如，如果你的数据对象有两个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class MyHandlers &#123;</span><br><span class="line">    public void onClickFriend(View view) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绑定表达式可以为 <code>View</code> 分配一个点击监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">   &lt;data&gt;</span><br><span class="line">       &lt;variable name=&quot;handlers&quot; type=&quot;com.example.MyHandlers&quot;/&gt;</span><br><span class="line">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">   &lt;/data&gt;</span><br><span class="line">   &lt;LinearLayout</span><br><span class="line">       android:orientation=&quot;vertical&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">       &lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:text=&quot;@&#123;user.firstName&#125;&quot;</span><br><span class="line">           android:onClick=&quot;@&#123;handlers::onClickFriend&#125;&quot;/&gt;</span><br><span class="line">   &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>
<p>请注意，表达式中方法的签名必须与监听器对象中方法的签名完全匹配。</p>
<h3 id="监听器绑定"><a href="#监听器绑定" class="headerlink" title="监听器绑定"></a>监听器绑定</h3><p>监听器绑定是事件发生时运行的绑定表达式。类似于方法引用，但是允许你运行任意的数据绑定表达式。 此功能适用于 Gradle 2.0 版及更高版本的 Android Gradle 插件。</p>
<p>在方法引用中，方法的参数必须与事件侦听器的参数匹配。 在监听器绑定中，只有你的返回值必须与监听器的期望返回值相匹配（除非它返回值为 void ）。 例如，您可以有一个具有以下方法的 <code>Presenter</code> 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Presenter &#123;</span><br><span class="line">    public void onSaveClick(Task task)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你可以绑定你的点击事件到你的类中，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">  &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">      &lt;data&gt;</span><br><span class="line">          &lt;variable name=&quot;task&quot; type=&quot;com.android.example.Task&quot; /&gt;</span><br><span class="line">          &lt;variable name=&quot;presenter&quot; type=&quot;com.android.example.Presenter&quot; /&gt;</span><br><span class="line">      &lt;/data&gt;</span><br><span class="line">      &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">          &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">          android:onClick=&quot;@&#123;() -&gt; presenter.onSaveClick(task)&#125;&quot; /&gt;</span><br><span class="line">      &lt;/LinearLayout&gt;</span><br><span class="line">  &lt;/layout&gt;</span><br></pre></td></tr></table></figure>
<p>监听器仅可以允许用 lambda 表达式作为根元素。 当表达式中有回调时，数据绑定会自动为事件创建必要的侦听器和注册表。 当视图触发事件时，数据绑定将评估给定的表达式。 就像在常规的绑定表达式一样，当这些监听器表达式被评估的时候，你仍然可以获取数据绑定的空值和保证线程安全。</p>
<p>请注意，在上面的例子中，我们没有定义传入 <code>onClick(android.view.View)</code> 的视图参数。 监听器绑定为监听器参数提供了两个选择：您可以忽略该方法的所有参数或将其全部命名。 如果您想要命名参数，则可以在表达式中使用它们。 例如，上面的表达式可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick=&quot;@&#123;(view) -&gt; presenter.onSaveClick(task)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>或者如果你想使用表达式中的参数，可以像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Presenter &#123;</span><br><span class="line">    public void onSaveClick(View view, Task task)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick=&quot;@&#123;(theView) -&gt; presenter.onSaveClick(theView, task)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>你可以在 lambda 表达式中使用多个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Presenter &#123;</span><br><span class="line">    public void onCompletedChanged(Task task, boolean completed)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;CheckBox </span><br><span class="line">        android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:onCheckedChanged=&quot;@&#123;(cb, isChecked) -&gt; presenter.completeChanged(task, isChecked)&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>如果正在侦听的事件返回值不是 <code> void</code>，则表达式必须返回相同类型的值。 例如，如果你想监听长按事件，你的表达式应该返回布尔值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Presenter &#123;</span><br><span class="line">    public boolean onLongClick(View view, Task task)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onLongClick=&quot;@&#123;(theView) -&gt; presenter.onLongClick(theView, task)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>如果由于空对象而无法评估表达式，Data Binding 将返回该类型的默认 Java 值。 例如，引用类型为 <code>null</code>，<code>int</code> 为 <code>0</code>，<code>boolean</code> 为<code> false</code> 等等。</p>
<p>如果您需要使用带谓词的表达式（例如三元），则可以使用 <code>void</code> 作为符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:onClick=&quot;@&#123;(v) -&gt; v.isVisible() ? doSomething() : void&#125;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="避免复杂的监听器"><a href="#避免复杂的监听器" class="headerlink" title="避免复杂的监听器"></a>避免复杂的监听器</h4><p>监听器表达式非常强大，可以让你的代码变得非常容易阅读。 另一方面，包含复杂表达式的监听器也会使您的布局难以阅读和维护。这些表达式应该像从 UI 中传递可用数据到回调方法一样简单。你应该从侦听器表达式调用的回调方法内实现业务逻辑。<br>存在一些专门的单击事件处理程序，它需要除 <code>android:onClick</code> 之外的其他属性以避免冲突。 已创建了以下属性以避免这种冲突：</p>
<table>
<thead>
<tr>
<th>Class</th>
<th>Listener Setter</th>
<th>Attribute</th>
</tr>
</thead>
<tbody><tr>
<td><code>SearchView</code></td>
<td><code>setOnSearchClickListener(View.OnClickListener)</code></td>
<td><code> android:onSearchClick</code></td>
</tr>
<tr>
<td><code>ZoomControls</code></td>
<td><code>setOnZoomInClickListener(View.OnClickListener)</code></td>
<td><code>android:onZoomIn</code></td>
</tr>
<tr>
<td><code>ZoomControls</code></td>
<td><code>setOnZoomOutClickListener(View.OnClickListener)</code></td>
<td><code>android:onZoomOut</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="布局文件细节"><a href="#布局文件细节" class="headerlink" title="布局文件细节"></a>布局文件细节</h2><h3 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h3><p>数据元素内可以使用零个或多个 <code>import</code> 元素。 这些就像在 Java 中一样可以轻松地引用类到你的布局文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.view.View&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>
<p>现在 <code>View </code> 类可以在你的绑定表达式中使用了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">   android:text=&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">   android:visibility=&quot;@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>如果类名有冲突的话，其中一个类则需起别名了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;import type=&quot;android.view.View&quot;/&gt;</span><br><span class="line">&lt;import type=&quot;com.example.real.estate.View&quot; alias=&quot;Vista&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>现在，在布局文件中，<code>Vista</code> 被当作 <code>com.example.real.estate.View</code> 引入，<code>View</code> 被当作 <code>android.view.View</code> 引入。 导入的类型可以用作变量和表达式中的类型引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;java.util.List&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot; type=&quot;User&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;userList&quot; type=&quot;List&amp;lt;User&amp;gt;&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Android Studio 尚未处理导入，因此自动导入变量在你的的 IDE 中可能无法完成。 你的应用程序仍然可以正常编译，你可以通过在变量定义中使用完全限定的名称来解决 IDE 的这个问题。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">   android:text=&quot;@&#123;((User)(user.connection)).lastName&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>当在表达式中引用静态字段和方法时，也可以使用导入的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;com.example.MyStringUtils&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">&lt;TextView</span><br><span class="line">   android:text=&quot;@&#123;MyStringUtils.capitalize(user.lastName)&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>就像在 Java 文件中一样，<code>java.lang.*</code> 会被自动导入。</p>
<h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p><code>data</code> 元素内可以使用任意的 <code>variable</code>。 每个变量表示可以在布局中设置的属性，以用于布局文件中的绑定表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.graphics.drawable.Drawable&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot;  type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;image&quot; type=&quot;Drawable&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;note&quot;  type=&quot;String&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>
<p>变量类型在编译时被检查，所以如果一个变量实现了 <code>Observable</code> 或者一个 <code>observable collection</code>，那么它应该被反映在类型中。 如果变量是没有实 <code>Observable</code> 接口的基类或接口，那么它将不会被观察！</p>
<p>当不同的配置（例如横向或纵向）有不同的布局文件时，变量将被合并。 这些布局文件之间不得有冲突的变量定义。</p>
<p>生成的绑定类将为每个描述的变量设置一个 <code>setter</code> 和 <code>getter</code> 方法。 变量将采用默认的 Java 值，直到调用 <code>setter</code> 为止 。对于引用类型为 <code>null</code>，对于 <code>int</code> 为<code>0</code>，对于 <code>boolean</code> 为 <code>false</code> 等。</p>
<h3 id="自定义绑定类的名字"><a href="#自定义绑定类的名字" class="headerlink" title="自定义绑定类的名字"></a>自定义绑定类的名字</h3><p> 默认情况下，根据布局文件的名称生成一个绑定类，以大写字母开头，删除下划线（_）并之后的单词首字母大写，然后添加后缀 <code>Binding</code>。 这个类将被放置在模块包下的数据绑定包中。 例如，布局文件 <code>contact_item.xml</code> 将生成 <code>ContactItemBinding</code>。 如果模块包是 <code>com.example.my.app</code>，那么它将被放置在 <code>com.example.my.app.databinding</code> 中。</p>
<p>绑定类可以通过调整 <code>data</code> 元素的 <code>class</code> 属性来重命名或放置在不同的包中。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;data class=&quot;ContactItem&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>
<p>这会在模块包中的数据绑定包中生成绑定类 <code>ContactItem</code>。 如果该类应该在模块包中的其他包中生成，则可以用“.”作为前缀：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;data class=&quot;.ContactItem&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，直接在模块包中生成了 <code>ContactItem</code>。 如果提供完整的包，则可以使用任意的包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;data class=&quot;com.example.ContactItem&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h3><p>通过在属性中使用应用程序命名空间和变量名称，变量可以从包含的布局中传递到包含的布局的绑定中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line">   &lt;data&gt;</span><br><span class="line">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">   &lt;/data&gt;</span><br><span class="line">   &lt;LinearLayout</span><br><span class="line">       android:orientation=&quot;vertical&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">       &lt;include layout=&quot;@layout/name&quot;</span><br><span class="line">           bind:user=&quot;@&#123;user&#125;&quot;/&gt;</span><br><span class="line">       &lt;include layout=&quot;@layout/contact&quot;</span><br><span class="line">           bind:user=&quot;@&#123;user&#125;&quot;/&gt;</span><br><span class="line">   &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>name.xml</code> 和 <code>contact.xml</code> 布局文件中都必须有一个 <code>user</code> 变量。</p>
<p>数据绑定不支持 <code>include</code> 作为 <code>merge</code> 元素的直接子元素。 例如，不支持以下布局：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line">   &lt;data&gt;</span><br><span class="line">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">   &lt;/data&gt;</span><br><span class="line">   &lt;merge&gt;</span><br><span class="line">       &lt;include layout=&quot;@layout/name&quot;</span><br><span class="line">           bind:user=&quot;@&#123;user&#125;&quot;/&gt;</span><br><span class="line">       &lt;include layout=&quot;@layout/contact&quot;</span><br><span class="line">           bind:user=&quot;@&#123;user&#125;&quot;/&gt;</span><br><span class="line">   &lt;/merge&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>

<h3 id="表达式语言"><a href="#表达式语言" class="headerlink" title="表达式语言"></a>表达式语言</h3><h4 id="共同特征"><a href="#共同特征" class="headerlink" title="共同特征"></a>共同特征</h4><p>表达式语言看起来很像 Java 表达式。 这些是一样的：</p>
<ul>
<li>Mathematical <code>+ - / * %</code></li>
<li>String concatenation <code>+</code></li>
<li>Logical &amp;&amp; <code>||</code></li>
<li>Binary <code> &amp; | ^</code></li>
<li>Unary <code>+ - ! ~</code></li>
<li>Shift <code>&gt;&gt; &gt;&gt;&gt; &lt;&lt;</code></li>
<li>Comparison <code>== &gt; &lt; &gt;= &lt;=</code></li>
<li><code>instanceof</code></li>
<li>Grouping <code>()</code></li>
<li>Literals - character, String, numeric, <code>null</code></li>
<li>Cast</li>
<li>Method calls</li>
<li>Field access</li>
<li>Array access <code>[]</code></li>
<li>Ternary operator <code>?:</code><br>例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;String.valueOf(index + 1)&#125;&quot;</span><br><span class="line">android:visibility=&quot;@&#123;age &lt; 13 ? View.GONE : View.VISIBLE&#125;&quot;</span><br><span class="line">android:transitionName=&#x27;@&#123;&quot;image_&quot; + id&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="缺少的操作"><a href="#缺少的操作" class="headerlink" title="缺少的操作"></a>缺少的操作</h4><p>你在 Java 中使用的一些表达式语法并不支持绑定操作。</p>
<ul>
<li><code>this</code></li>
<li><code>super</code></li>
<li><code>new</code></li>
<li>明确的泛型调用</li>
</ul>
<h4 id="空的合并运算符"><a href="#空的合并运算符" class="headerlink" title="空的合并运算符"></a>空的合并运算符</h4><p>空合并运算符 <code>??</code> 会选择左边的运算结果（如果它不是 <code>null</code> 的话）或右边的运算结果（如果它是 <code>null</code> 的话）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;user.displayName ?? user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>这在功能上等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;user.displayName != null ? user.displayName : user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="属性引用"><a href="#属性引用" class="headerlink" title="属性引用"></a>属性引用</h4><p>当一个表达式引用一个类的属性时，它对字段，<code>setter</code> 和 <code>ObservableFields</code> 使用相同的格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="避免空指针异常"><a href="#避免空指针异常" class="headerlink" title="避免空指针异常"></a>避免空指针异常</h4><p>生成的数据绑定代码会自动检查空值并避免空指针异常。 例如，在表达式 <code>@ &#123;user.name&#125;</code> 中，如果 <code>user</code> 为 null，则 <code>user.name</code> 将被分配其默认值（<code>null</code>）。 如果引用 <code>user.age</code>，其中age是一个 <code>int</code>，那么它将默认为0。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>通用的集合：数组，列表，SparseArray ，map，可以使用 <code>[]</code> 运算符来方便地访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.util.SparseArray&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;java.util.Map&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;java.util.List&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;list&quot; type=&quot;List&amp;lt;String&amp;gt;&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&amp;lt;String&amp;gt;&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;map&quot; type=&quot;Map&amp;lt;String, String&amp;gt;&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;list[index]&#125;&quot;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;sparse[index]&#125;&quot;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;map[key]&#125;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="字符串文本"><a href="#字符串文本" class="headerlink" title="字符串文本"></a>字符串文本</h4><p>在属性值两边使用单引号时，则表达式中使用双引号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&#x27;@&#123;map[&quot;firstName&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p>也可以使用双引号来包围属性值。 这样做时，字符串文字应该使用单引号 <code>&#39;</code> 或者反引号（&#96;）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;map[`firstName`&#125;&quot;</span><br><span class="line">android:text=&quot;@&#123;map[&#x27;firstName&#x27;]&#125;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>  使用正常的语法可以将资源作为表达式的一部分进行访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:padding=&quot;@&#123;large? @dimen/largePadding : @dimen/smallPadding&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>格式字符串和复数可以通过提供参数来评估：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;@string/nameFormat(firstName, lastName)&#125;&quot;</span><br><span class="line">android:text=&quot;@&#123;@plurals/banana(bananaCount)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>当一个复数有多个参数时，所有参数都应该传递：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Have an orange</span><br><span class="line">Have %d oranges</span><br><span class="line">android:text=&quot;@&#123;@plurals/orange(orangeCount, orangeCount)&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>一些资源需要明确的类型评估：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Normal Reference</th>
<th>Expression Reference</th>
</tr>
</thead>
<tbody><tr>
<td>String[]</td>
<td>@array</td>
<td>@stringArray</td>
</tr>
<tr>
<td>int[]</td>
<td>@array</td>
<td>@intArray</td>
</tr>
<tr>
<td>TypedArray</td>
<td>@array</td>
<td>@typedArray</td>
</tr>
<tr>
<td>Animator</td>
<td>@animator</td>
<td>@animator</td>
</tr>
<tr>
<td>StateListAnimator</td>
<td>@animator</td>
<td>@stateListAnimator</td>
</tr>
<tr>
<td>color int</td>
<td>@color</td>
<td>@color</td>
</tr>
<tr>
<td>ColorStateList</td>
<td>@color</td>
<td>@colorStateList</td>
</tr>
</tbody></table>
<hr>
<h2 id="Data-Objects"><a href="#Data-Objects" class="headerlink" title="Data Objects"></a>Data Objects</h2><p>任何普通的旧 Java 对象（POJO）都可以用于数据绑定，但修改 POJO 不会导致 UI<br> 更新。 数据绑定的真正威力在于通过给你的数据对象在数据改变时提供通知。 有三种不同的数据更改通知机制，<code>Observable objects</code>, <code>observable fields</code>,  <code>observable collections</code>.</p>
<p>当这些可观察的数据对象被绑定到 UI，并且数据对象的属性改变时，UI 将被自动更新。</p>
<h3 id="Observable-Objects"><a href="#Observable-Objects" class="headerlink" title="Observable Objects"></a>Observable Objects</h3><p>实现 <code>Observable</code> 接口的类将允许绑定单个侦听器附加到绑定对象，以侦听该对象上所有属性的更改。</p>
<p><code>Observable</code> 接口具有添加和删除侦听器的功能，但通知是由开发者决定的。 为了简化开发，创建了基类 <code>BaseObservable</code>，以实现侦听器注册机制。 数据类实现者仍然负责通知属性的更改。 这是通过给 getter 分配一个 <code>Bindable</code> 注解并通知 setter 来完成的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static class User extends BaseObservable &#123;</span><br><span class="line">   private String firstName;</span><br><span class="line">   private String lastName;</span><br><span class="line">   @Bindable</span><br><span class="line">   public String getFirstName() &#123;</span><br><span class="line">       return this.firstName;</span><br><span class="line">   &#125;</span><br><span class="line">   @Bindable</span><br><span class="line">   public String getLastName() &#123;</span><br><span class="line">       return this.lastName;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setFirstName(String firstName) &#123;</span><br><span class="line">       this.firstName = firstName;</span><br><span class="line">       notifyPropertyChanged(BR.firstName);</span><br><span class="line">   &#125;</span><br><span class="line">   public void setLastName(String lastName) &#123;</span><br><span class="line">       this.lastName = lastName;</span><br><span class="line">       notifyPropertyChanged(BR.lastName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Bindable</code> 注解在编译期间在 BR 类中生成一个条目。 BR 类文件将在模块包中生成。 如果数据类的基类没有改变，<code>Observable</code> 接口可以使用方便的 <code>PropertyChangeRegistry</code> 来实现，以有效地存储和通知监听器。</p>
<h3 id="ObservableFields"><a href="#ObservableFields" class="headerlink" title="ObservableFields"></a>ObservableFields</h3><p>创建 <code>Observable</code> 类需要做一点工作，所以想要节省时间或拥有很少属性的开发人员可以使用 <code>ObservableField</code> 及其同胞 <code>ObservableBoolean</code>，<code>ObservableByte</code>，<code>ObservableChar</code>，<code>ObservableShort</code>，<code>ObservableInt</code>，<code>ObservableLong</code>，<code>ObservableFloat</code>，<code>ObservableDoubl</code> 和 <code>ObservableParcelable</code>。 <code>ObservableFields</code> 是具有单个字段的独立的可观察对象。 原始版本在访问操作期间避免装箱和取消装箱。 要使用，请在数据类中创建一个公共 final 字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static class User &#123;</span><br><span class="line">   public final ObservableField&lt;String&gt; firstName =</span><br><span class="line">       new ObservableField&lt;&gt;();</span><br><span class="line">   public final ObservableField&lt;String&gt; lastName =</span><br><span class="line">       new ObservableField&lt;&gt;();</span><br><span class="line">   public final ObservableInt age = new ObservableInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这样！要访问该值，请使用 set 和 get 方法访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.firstName.set(&quot;Google&quot;);</span><br><span class="line">int age = user.age.get();</span><br></pre></td></tr></table></figure>

<h3 id="Observable-Collections"><a href="#Observable-Collections" class="headerlink" title="Observable Collections"></a>Observable Collections</h3><p>一些应用程序使用更多的动态结构来保存数据，观察集合允许对这些数据对象进行键值访问。当键是引用类型（如 String）时，<code>ObservableArrayMap</code> 非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayMap&lt;String, Object&gt; user = new ObservableArrayMap&lt;&gt;();</span><br><span class="line">user.put(&quot;firstName&quot;, &quot;Google&quot;);</span><br><span class="line">user.put(&quot;lastName&quot;, &quot;Inc.&quot;);</span><br><span class="line">user.put(&quot;age&quot;, 17);</span><br></pre></td></tr></table></figure>
<p>在布局文件中，map 通过字符串键来访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.databinding.ObservableMap&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot; type=&quot;ObservableMap&amp;lt;String, Object&amp;gt;&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">&lt;TextView</span><br><span class="line">   android:text=&#x27;@&#123;user[&quot;lastName&quot;]&#125;&#x27;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">   android:text=&#x27;@&#123;String.valueOf(1 + (Integer)user[&quot;age&quot;])&#125;&#x27;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>当键是整形是，可以使用 <code>ObservableArrayList</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObservableArrayList&lt;Object&gt; user = new ObservableArrayList&lt;&gt;();</span><br><span class="line">user.add(&quot;Google&quot;);</span><br><span class="line">user.add(&quot;Inc.&quot;);</span><br><span class="line">user.add(17);</span><br></pre></td></tr></table></figure>
<p>在布局中，列表可以通过索引来访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.databinding.ObservableList&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;com.example.my.app.Fields&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot; type=&quot;ObservableList&amp;lt;Object&amp;gt;&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">&lt;TextView</span><br><span class="line">   android:text=&#x27;@&#123;user[Fields.LAST_NAME]&#125;&#x27;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">   android:text=&#x27;@&#123;String.valueOf(1 + (Integer)user[Fields.AGE])&#125;&#x27;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="生成绑定类"><a href="#生成绑定类" class="headerlink" title="生成绑定类"></a>生成绑定类</h2><p>生成的绑定类将布局变量与布局中的视图链接起来。 如前所述，绑定的名称和包可能是自定义的。 生成的绑定类都扩展了 <code>ViewDataBinding</code>。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>应该在 inflate 之后立即创建绑定，以确保 View 层次结构不受干扰。 有几种方法可以绑定到布局。 最常见的是在绑定类中使用静态方法。inflate 方法 inflate View 层次结构，一步到位。 有一个更简单的版本，只需要一个 <code>LayoutInflater</code> 和一个 <code>ViewGroup</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater);</span><br><span class="line">MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater, viewGroup, false);</span><br></pre></td></tr></table></figure>
<p>如果布局使用不同的机制 inflate，它可能会被分开绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot);</span><br></pre></td></tr></table></figure>
<p>有时绑定不能预先知道。 在这种情况下，可以使用 <code>DataBindingUtil</code> 类创建绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater, layoutId, parent, attachToParent);</span><br><span class="line">ViewDataBinding binding = DataBindingUtil.bindTo(viewRoot, layoutId);</span><br></pre></td></tr></table></figure>

<h3 id="Views-With-IDs"><a href="#Views-With-IDs" class="headerlink" title="Views With IDs"></a>Views With IDs</h3><p>将在布局中为每个视图生成一个公开的 final 字段。 该绑定在视图层次结构上执行单个传递，提取带有 ID 的视图。 这个机制可以比调用多个视图的 <code>findViewById</code> 更快。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">   &lt;data&gt;</span><br><span class="line">       &lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">   &lt;/data&gt;</span><br><span class="line">   &lt;LinearLayout</span><br><span class="line">       android:orientation=&quot;vertical&quot;</span><br><span class="line">       android:layout_width=&quot;match_parent&quot;</span><br><span class="line">       android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">       &lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:text=&quot;@&#123;user.firstName&#125;&quot;</span><br><span class="line">   android:id=&quot;@+id/firstName&quot;/&gt;</span><br><span class="line">       &lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:text=&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">  android:id=&quot;@+id/lastName&quot;/&gt;</span><br><span class="line">   &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>
<p>会生成带有一下字段的绑定类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final TextView firstName;</span><br><span class="line">public final TextView lastName;</span><br></pre></td></tr></table></figure>
<p>IDs 不像没有数据绑定那样必要，但是仍然有一些情况下代码需要访问视图。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>每个变量将被赋予访问器方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.graphics.drawable.Drawable&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot;  type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;image&quot; type=&quot;Drawable&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;note&quot;  type=&quot;String&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>
<p>会在绑定类中生成 setter 和 getter 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract com.example.User getUser();</span><br><span class="line">public abstract void setUser(com.example.User user);</span><br><span class="line">public abstract Drawable getImage();</span><br><span class="line">public abstract void setImage(Drawable image);</span><br><span class="line">public abstract String getNote();</span><br><span class="line">public abstract void setNote(String note);</span><br></pre></td></tr></table></figure>

<h3 id="ViewStubs"><a href="#ViewStubs" class="headerlink" title="ViewStubs"></a>ViewStubs</h3><p><code>ViewStub</code> 与普通视图有点不同。 他们从不可见的时候开始，当他们要么变得可见时，要么被明确告知 inflate 时，他们通过 inflate 另一个布局来取代布局。</p>
<p>由于 <code>ViewStub</code> 本质上从视图层次中消失，所以绑定对象中的视图也必须消失以允许收集。 因为视图是 final 的，所以 <code>ViewStubProxy</code> 对象代替了<code>ViewStub</code>，当 <code>ViewStub</code> 存在时，开发人员可以访问 <code>ViewStub</code>，并且在 <code>ViewStub</code>被 inflate 时也可以访问被 inflate 的视图。</p>
<p>当 inflate 另一个布局时，必须为新的布局建立绑定。因此，<code>ViewStubProxy</code> 必须侦听 <code>ViewStub</code> 的 <code>ViewStub.OnInflateListener</code> 并在此时建立绑定。由于只有一个可以存在，<code>ViewStubProxy</code> 允许开发者在建立绑定之后设置一个 <code>OnInflateListener</code> 对象。</p>
<h3 id="高级绑定"><a href="#高级绑定" class="headerlink" title="高级绑定"></a>高级绑定</h3><h4 id="动态变量"><a href="#动态变量" class="headerlink" title="动态变量"></a>动态变量</h4><p>有时，特定的绑定类将不被知道。 例如，针对任意布局的 <code>RecyclerView.Adapter</code> 将不知道具体的绑定类。 它仍然必须在 <code>onBindViewHolder(VH,int)</code> 期间分配绑定值。</p>
<p>在这个例子中，<code>RecyclerView</code> 绑定的所有布局都有一个 <strong>item</strong> 变量。<code>BindingHolder</code> 有一个返回 <code>ViewDataBinding</code> 基类的 <code>getBinding</code> 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void onBindViewHolder(BindingHolder holder, int position) &#123;</span><br><span class="line">   final T item = mItems.get(position);</span><br><span class="line">   holder.getBinding().setVariable(BR.item, item);</span><br><span class="line">   holder.getBinding().executePendingBindings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="立即绑定"><a href="#立即绑定" class="headerlink" title="立即绑定"></a>立即绑定</h4><p>当变量或 observable 变化时，绑定将被安排在下一帧之前改变。但有时候，绑定必须立即执行。要强制执行，请使用 <code>executePendingBindings()</code> 方法。</p>
<h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>只要不是集合，就可以在后台线程中更改数据模型。数据绑定将在评估时本地化每个变量&#x2F;字段，以避免任何并发问题。</p>
<hr>
<h2 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h2><p>每当绑定值发生变化时，生成的绑定类必须使用绑定表达式在视图上调用setter方法。 数据绑定框架可以自定义调用哪个方法来设置值。</p>
<h3 id="自动的设置器"><a href="#自动的设置器" class="headerlink" title="自动的设置器"></a>自动的设置器</h3><p>对于一个属性，数据绑定将试图找到设置属性的方法。属性的命名空间并不重要，只有属性名称本身才重要。例如，与 <code>TextView</code> 的属性 <code>android：text</code> 相关联的表达式将查找 setText(String)。 如果表达式返回 int，那么数据绑定将搜索一个 setText(int) 方法。请注意让表达式返回正确的类型，如果需要的话就进行转换。即使给定名称不存在任何属性，数据绑定也可以工作。 然后，您可以使用数据绑定轻松地为任何 setter 创建属性。 例如，support 库中的 <code>DrawerLayout</code> 没有任何属性，但是有很多 setter。 您可以使用自动设置器来使用其中的一个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v4.widget.DrawerLayout</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    app:scrimColor=&quot;@&#123;@color/scrim&#125;&quot;</span><br><span class="line">    app:drawerListener=&quot;@&#123;fragment.drawerListener&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="重命名设置器"><a href="#重命名设置器" class="headerlink" title="重命名设置器"></a>重命名设置器</h3><p>一些属性的设置器会与名称不匹配。 对于这些方法，一个属性可能通过 <code>BindingMethods</code> 注解与设置器关联。 这必须与一个类相关联，每个重命名的方法一个包含一个 <code>BindingMethod</code> 注解。例如，<code>android：tint</code> 属性确实与 <code>setImageTintList(ColorStateList)</code> 关联，而不是 <code>setTint</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@BindingMethods(&#123;</span><br><span class="line">       @BindingMethod(type = &quot;android.widget.ImageView&quot;,</span><br><span class="line">                      attribute = &quot;android:tint&quot;,</span><br><span class="line">                      method = &quot;setImageTintList&quot;),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>开发人员不太可能需要重命名设置器， 安卓框架已经为这些属性实现了。</p>
<h3 id="自定义设置器"><a href="#自定义设置器" class="headerlink" title="自定义设置器"></a>自定义设置器</h3><p>一些属性需要自定义绑定逻辑。 例如，<code>android:paddingLeft</code> 属性没有关联的设置器。 相反，setPadding(eft, top, right, bottom) 存在。 使用 <code>BindingAdapter</code> 注释的静态绑定适配器方法允许开发人员自定义如何调用属性的设置器。</p>
<p>安卓属性已经创建了 <code>BindingAdapters</code>。 例如，这里是 <code>paddingLeft</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&quot;android:paddingLeft&quot;)</span><br><span class="line">public static void setPaddingLeft(View view, int padding) &#123;</span><br><span class="line">   view.setPadding(padding,</span><br><span class="line">                   view.getPaddingTop(),</span><br><span class="line">                   view.getPaddingRight(),</span><br><span class="line">                   view.getPaddingBottom());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绑定适配器对其他类型的自定义非常有用。 例如，一个自定义的加载器可以被调用脱机线程来加载一个图像。当发生冲突时，开发人员创建的绑定适配器将覆盖数据绑定默认适配器。您也可以让适配器接收多个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&#123;&quot;bind:imageUrl&quot;, &quot;bind:error&quot;&#125;)</span><br><span class="line">public static void loadImage(ImageView view, String url, Drawable error) &#123;</span><br><span class="line">   Picasso.with(view.getContext()).load(url).error(error).into(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView app:imageUrl=&quot;@&#123;venue.imageUrl&#125;&quot;</span><br><span class="line">app:error=&quot;@&#123;@drawable/venueError&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>如果 imageUrl 和 error 都用于 <code>ImageView</code> 且 imageUrl 是字符串，并且 error 是 drawable，则将调用此适配器。<br>自定义名称空间在匹配过程中被忽略。<br>也可以为 android 命名空间编写适配器。<br>绑定适配器方法可以选择在其处理程序中使用旧值。 采用新旧值的方法，应该把属性的所有旧的值放在第一位，然后是新的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&quot;android:paddingLeft&quot;)</span><br><span class="line">public static void setPaddingLeft(View view, int oldPadding, int newPadding) &#123;</span><br><span class="line">   if (oldPadding != newPadding) &#123;</span><br><span class="line">       view.setPadding(newPadding,</span><br><span class="line">                       view.getPaddingTop(),</span><br><span class="line">                       view.getPaddingRight(),</span><br><span class="line">                       view.getPaddingBottom());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件处理器只能用于只有一个抽象方法的接口或抽象类。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&quot;android:onLayoutChange&quot;)</span><br><span class="line">public static void setOnLayoutChangeListener(View view, View.OnLayoutChangeListener oldValue,</span><br><span class="line">       View.OnLayoutChangeListener newValue) &#123;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        if (oldValue != null) &#123;</span><br><span class="line">            view.removeOnLayoutChangeListener(oldValue);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newValue != null) &#123;</span><br><span class="line">            view.addOnLayoutChangeListener(newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个监听器有多个方法时，它必须被分成多个监听器。例如，<code>View.OnAttachStateChangeListener</code> 有两个方法：<code>onViewAttachedToWindow()</code> 和 <code>onViewDetachedFromWindow()</code>。然后我们必须创建两个接口来区分它们的属性和处理器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="line">public interface OnViewDetachedFromWindow &#123;</span><br><span class="line">    void onViewDetachedFromWindow(View v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</span><br><span class="line">public interface OnViewAttachedToWindow &#123;</span><br><span class="line">    void onViewAttachedToWindow(View v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为更改一个侦听器也会影响另一个侦听器，所以我们必须有三个不同的绑定适配器，一个用于每个属性，另一个用于两个，它们都应该被设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&quot;android:onViewAttachedToWindow&quot;)</span><br><span class="line">public static void setListener(View view, OnViewAttachedToWindow attached) &#123;</span><br><span class="line">    setListener(view, null, attached);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@BindingAdapter(&quot;android:onViewDetachedFromWindow&quot;)</span><br><span class="line">public static void setListener(View view, OnViewDetachedFromWindow detached) &#123;</span><br><span class="line">    setListener(view, detached, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@BindingAdapter(&#123;&quot;android:onViewDetachedFromWindow&quot;, &quot;android:onViewAttachedToWindow&quot;&#125;)</span><br><span class="line">public static void setListener(View view, final OnViewDetachedFromWindow detach,</span><br><span class="line">        final OnViewAttachedToWindow attach) &#123;</span><br><span class="line">    if (VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        final OnAttachStateChangeListener newListener;</span><br><span class="line">        if (detach == null &amp;&amp; attach == null) &#123;</span><br><span class="line">            newListener = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            newListener = new OnAttachStateChangeListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onViewAttachedToWindow(View v) &#123;</span><br><span class="line">                    if (attach != null) &#123;</span><br><span class="line">                        attach.onViewAttachedToWindow(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onViewDetachedFromWindow(View v) &#123;</span><br><span class="line">                    if (detach != null) &#123;</span><br><span class="line">                        detach.onViewDetachedFromWindow(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        final OnAttachStateChangeListener oldListener = ListenerUtil.trackListener(view,</span><br><span class="line">                newListener, R.id.onAttachStateChangeListener);</span><br><span class="line">        if (oldListener != null) &#123;</span><br><span class="line">            view.removeOnAttachStateChangeListener(oldListener);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newListener != null) &#123;</span><br><span class="line">            view.addOnAttachStateChangeListener(newListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子比正常情况稍微复杂一点，因为视图对侦听器使添加和删除，而不是对 <code>View.OnAttachStateChangeListener</code> 使用set方法。  <code>android.databinding.adapters.ListenerUtil</code> 类有助于跟踪以前的监听器，以便它们可以在绑定适配器中被移除。通过使用 <code>@TargetApi(VERSION_CODES.HONEYCOMB_MR1)</code> 注解接口 <code>OnViewDetachedFromWindow</code> 和<code>OnViewAttachedToWindow</code>，数据绑定代码生成器知道只应在 API 12 或以上的设备上调用 <code>addOnAttachStateChangeListener(View.OnAttachStateChangeListener)</code> 来运行运行侦听器。</p>
<hr>
<h2 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h2><h3 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h3><p>从绑定表达式返回一个对象时，将从自动，重命名和自定义的设置器中选择一个设置器。 该对象将被转换为所选设置器的参数类型。<br>这对于那些使用 ObservableMaps 来保存数据的开发者来说是很方便的。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">   android:text=&#x27;@&#123;userMap[&quot;lastName&quot;]&#125;&#x27;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p><code>userMap</code> 返回一个对象，该对象将被自动转换为在 <code>setText(CharSequence)</code> 中找到的参数类型。 当参数类型可能混淆时，开发者需要在表达式中输入。</p>
<h3 id="自定义转换"><a href="#自定义转换" class="headerlink" title="自定义转换"></a>自定义转换</h3><p>有时转换应该在特定类型之间自动进行。 例如，设置 background 时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">   android:background=&quot;@&#123;isError ? @color/red : @color/white&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>在这里，背景需要一个 <code>Drawable</code>，但是颜色是一个整数。每当一个 <code>Drawable</code> 被判断该返回一个整数时，该整形应该被转换成一个 <code>ColorDrawable</code>。 这个转换是通过一个带有 <code>BindingConversion</code> 注解的静态方法完成的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@BindingConversion</span><br><span class="line">public static ColorDrawable convertColorToDrawable(int color) &#123;</span><br><span class="line">   return new ColorDrawable(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，转换只发生在设置器级别，所以不允许混合类型，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">   android:background=&quot;@&#123;isError ? @drawable/error : @color/white&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Android-Studio-支持数据绑定"><a href="#Android-Studio-支持数据绑定" class="headerlink" title="Android Studio 支持数据绑定"></a>Android Studio 支持数据绑定</h2><p>Android Studio 支持数据绑定代码的许多代码编辑功能。例如，它支持数据绑定表达式的以下功能：</p>
<ul>
<li>语法高亮</li>
<li>表达式语法错误的提示</li>
<li>XML代码完成</li>
<li>包括导航（如导航到声明）和快速文档的参考</li>
</ul>
<blockquote>
<p>注意：如果没有错误，则数组和一般类型（如 <code>Observable</code> 类）可能会显示错误。</p>
</blockquote>
<p>预览窗格显示数据绑定表达式的默认值（如果提供的话）。在以下示例摘录布局XML文件中的元素时，预览窗格将在 <code>TextView</code> 中显示 <code>PLACEHOLDER</code> 默认文本值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">   android:text=&quot;@&#123;user.firstName, default=PLACEHOLDER&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>如果需要在项目设计阶段显示默认值，则还可以使用工具属性而不是默认表达式值，如 <a target="_blank" rel="noopener" href="http://tools.android.com/tips/layout-designtime-attributes">Design Time Layout Attributes</a> 中所述。</p>
<hr>
<blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://developer.android.google.cn/topic/libraries/data-binding/index.html">https://developer.android.google.cn/topic/libraries/data-binding/index.html</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://doforce.github.io">Edgar</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://doforce.github.io/2018/translation/android-data-binding-translation/">https://doforce.github.io/2018/translation/android-data-binding-translation/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://doforce.github.io" target="_blank">Breathing Land</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/translation/">translation</a><a class="post-meta__tags" href="/tags/android/">android</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2018/github-spider/"><img class="next-cover" src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">用爬虫写一个 GitHub Trending API</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Edgar</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Data-Binding-%E7%B1%BB%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">Data Binding 类库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.</span> <span class="toc-text">构建环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Binding-%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">Data Binding 布局文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA-Data-Binding-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">编写你的第一个 Data Binding 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.2.</span> <span class="toc-text">数据对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.3.</span> <span class="toc-text">绑定数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">1.2.4.</span> <span class="toc-text">事件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E7%BB%91%E5%AE%9A"><span class="toc-number">1.2.6.</span> <span class="toc-text">监听器绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%A4%8D%E6%9D%82%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">避免复杂的监听器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E7%BB%86%E8%8A%82"><span class="toc-number">1.3.</span> <span class="toc-text">布局文件细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Imports"><span class="toc-number">1.3.1.</span> <span class="toc-text">Imports</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Variables"><span class="toc-number">1.3.2.</span> <span class="toc-text">Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%91%E5%AE%9A%E7%B1%BB%E7%9A%84%E5%90%8D%E5%AD%97"><span class="toc-number">1.3.3.</span> <span class="toc-text">自定义绑定类的名字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Includes"><span class="toc-number">1.3.4.</span> <span class="toc-text">Includes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80"><span class="toc-number">1.3.5.</span> <span class="toc-text">表达式语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">共同特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E5%B0%91%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">缺少的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E7%9A%84%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">空的合并运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">属性引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.5.5.</span> <span class="toc-text">避免空指针异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.3.5.6.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%87%E6%9C%AC"><span class="toc-number">1.3.5.7.</span> <span class="toc-text">字符串文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.5.8.</span> <span class="toc-text">资源</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Objects"><span class="toc-number">1.4.</span> <span class="toc-text">Data Objects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Observable-Objects"><span class="toc-number">1.4.1.</span> <span class="toc-text">Observable Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ObservableFields"><span class="toc-number">1.4.2.</span> <span class="toc-text">ObservableFields</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observable-Collections"><span class="toc-number">1.4.3.</span> <span class="toc-text">Observable Collections</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E7%BB%91%E5%AE%9A%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">生成绑定类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">1.5.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Views-With-IDs"><span class="toc-number">1.5.2.</span> <span class="toc-text">Views With IDs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewStubs"><span class="toc-number">1.5.4.</span> <span class="toc-text">ViewStubs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%BB%91%E5%AE%9A"><span class="toc-number">1.5.5.</span> <span class="toc-text">高级绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">动态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E7%BB%91%E5%AE%9A"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">立即绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">后台线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.6.</span> <span class="toc-text">属性设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%99%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">自动的设置器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E8%AE%BE%E7%BD%AE%E5%99%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">重命名设置器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BE%E7%BD%AE%E5%99%A8"><span class="toc-number">1.6.3.</span> <span class="toc-text">自定义设置器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">转换器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.7.1.</span> <span class="toc-text">对象转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.7.2.</span> <span class="toc-text">自定义转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-Studio-%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-number">1.8.</span> <span class="toc-text">Android Studio 支持数据绑定</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><div class="content"><a class="title" href="/2018/translation/android-data-binding-translation/" title="Data Binding （中文文档）">Data Binding （中文文档）</a><time datetime="2018-01-16T03:43:00.000Z" title="发表于 2018-01-16 11:43:00">2018-01-16</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2018/github-spider/" title="用爬虫写一个 GitHub Trending API">用爬虫写一个 GitHub Trending API</a><time datetime="2018-01-15T10:03:00.000Z" title="发表于 2018-01-15 18:03:00">2018-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Edgar</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>